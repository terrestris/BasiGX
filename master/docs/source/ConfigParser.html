<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* Copyright (c) 2015-present terrestris GmbH &amp; Co. KG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
<span id='BasiGX-util-ConfigParser'>/**
</span> * ConfigParser Util
 *
 * Parses an application context in JSON Format
 * in order to generate ol based layers and map with the given configuration.
 * @class BasiGX.util.ConfigParser
 */
/* Example appContext response from SHOGun 1:
 *
 *     {
 *       &quot;data&quot;:{
 *         &quot;merge&quot;:{
 *           &quot;id&quot;:3841,
 *           &quot;created_at&quot;:&quot;04.05.2015 12:05:29&quot;,
 *           &quot;updated_at&quot;:&quot;04.05.2015 12:05:29&quot;,
 *           &quot;app_user&quot;:&quot;default&quot;,
 *           &quot;name&quot;:&quot;test&quot;,
 *           &quot;language&quot;:&quot;DE&quot;,
 *           &quot;open&quot;:false,
 *           &quot;active&quot;:true,
 *           &quot;css&quot;:&quot;ext-all.css&quot;,
 *           &quot;description&quot;:null,
 *           &quot;shortdescription&quot;:null,
 *           &quot;url&quot;:&quot;client/gisclient/index-dev.html&quot;,
 *           &quot;startCenter&quot;:&quot;385067,5535472&quot;,
 *           &quot;startZoom&quot;:&quot;0&quot;,
 *           &quot;startResolution&quot;:&quot;560&quot;,
 *           &quot;startBbox&quot;:&quot;-106720,4973280,1040160,6406880&quot;,
 *           &quot;specialinstance&quot;:false,
 *           &quot;zoomslider&quot;:true,
 *           &quot;applicationheader&quot;:true,
 *           &quot;initiallegendvisibility&quot;:true,
 *           &quot;editableForCurrentUser&quot;:false,
 *           &quot;initiallyactivetoolpertab&quot;:&quot;t_pan_button&quot;,
 *           &quot;initialwestpanelstate&quot;:300,
 *           &quot;initialstatusbarstate&quot;:&quot;full&quot;,
 *           &quot;mapLayers&quot;:[
 *             {
 *               &quot;id&quot;:230,
 *               &quot;created_at&quot;:&quot;16.03.2015 11:55:48&quot;,
 *               &quot;updated_at&quot;:&quot;16.03.2015 11:55:48&quot;,
 *               &quot;app_user&quot;:&quot;auto-create-on-init&quot;,
 *               &quot;name&quot;:&quot;(mainz) Klimatische Wasserbilanz&quot;,
 *               &quot;type&quot;:&quot;WMS&quot;,
 *               &quot;isBaseLayer&quot;:false,
 *               &quot;alwaysInRange&quot;:null,
 *               &quot;visibility&quot;:true,
 *               &quot;displayInLayerSwitcher&quot;:true,
 *               &quot;attribution&quot;:null,
 *               &quot;gutter&quot;:null,
 *               &quot;projection&quot;:null,
 *               &quot;units&quot;:null,
 *               &quot;scales&quot;:null,
 *               &quot;resolutions&quot;:null,
 *               &quot;maxExtent&quot;:null,
 *               &quot;minExtent&quot;:null,
 *               &quot;maxResolution&quot;:null,
 *               &quot;minResolution&quot;:null,
 *               &quot;maxScale&quot;:null,
 *               &quot;minScale&quot;:null,
 *               &quot;numZoomLevels&quot;:null,
 *               &quot;displayOutsideMaxExtent&quot;:false,
 *               &quot;transitionEffect&quot;:null,
 *               &quot;metadata&quot;:[],
 *               &quot;groups&quot;:[
 *                 20,
 *                 19,
 *                 23
 *               ],
 *               &quot;owner&quot;:null,
 *               &quot;additionalOwners&quot;:[],
 *               &quot;url&quot;:&quot;/GDAWasser/geoserver.action&quot;,
 *               &quot;layers&quot;:&quot;GDA_Wasser:WRRL_WASSERBILANZ_EINSTUFUNG&quot;,
 *               &quot;transparent&quot;:true,
 *               &quot;singleTile&quot;:false,
 *               &quot;ratio&quot;:null,
 *               &quot;format&quot;:&quot;image/png8&quot;,
 *               &quot;language&quot;:&quot;de&quot;,
 *               &quot;description&quot;:null,
 *               &quot;exportable&quot;:true,
 *               &quot;queryableInfoFormat&quot;:null,
 *               &quot;editableForCurrentUser&quot;:false,
 *               &quot;sysLayer&quot;:true,
 *               &quot;digiLayer&quot;:false,
 *               &quot;specialLayer&quot;:false,
 *               &quot;specialLayerUrlTemplate&quot;:null,
 *               &quot;specialLayerWinWidth&quot;:null,
 *               &quot;specialLayerWinHeight&quot;:null,
 *               &quot;hoverField&quot;:&quot;{{GEMEINDE_BEZ}}&quot;,
 *               &quot;dataLayerWindowTitle&quot;:null,
 *               &quot;layerStyleConfigurable&quot;:null,
 *               &quot;temporaryLayer&quot;:false,
 *               &quot;rasterLayer&quot;:false,
 *               &quot;rasterLayerFeatureInfo&quot;:null,
 *               &quot;dataLayer&quot;:false,
 *               &quot;waterCourseLevel&quot;:0,
 *               &quot;geometryType&quot;:null,
 *               &quot;layerGroupName&quot;:null,
 *               &quot;tiled&quot;:true
 *             }
 *           ],
 *           &quot;grantedOverviewMapLayers&quot;:null,
 *           &quot;overviewMapLayers&quot;:[],
 *           &quot;grantedMapLayers&quot;:null,
 *           &quot;mapConfig&quot;:{
 *             &quot;id&quot;:13,
 *             &quot;created_at&quot;:&quot;16.03.2015 11:55:49&quot;,
 *             &quot;updated_at&quot;:&quot;16.03.2015 11:55:49&quot;,
 *             &quot;app_user&quot;:&quot;auto-create-on-init&quot;,
 *             &quot;name&quot;:&quot;default-mapconfig&quot;,
 *             &quot;mapId&quot;:&quot;stdmap&quot;,
 *             &quot;title&quot;:&quot;Map&quot;,
 *             &quot;projection&quot;:&quot;EPSG:25832&quot;,
 *             &quot;units&quot;:&quot;m&quot;,
 *             &quot;maxResolution&quot;:560,
 *             &quot;maxExtent&quot;:&quot;-106720,4973280,1040160,6406880&quot;,
 *             &quot;center&quot;:&quot;385067,5535472&quot;,
 *             &quot;resolutions&quot;:&quot;560, 280, 140, 70, 28, 14, 7, 2.8, 1.4&quot;,
 *             &quot;scales&quot;:null,
 *             &quot;zoom&quot;:0
 *           },
 *           &quot;grantedMapConfig&quot;:null,
 *           &quot;modules&quot;:[
 *             {
 *               &quot;id&quot;:1,
 *               &quot;created_at&quot;:&quot;16.03.2015 11:55:49&quot;,
 *               &quot;updated_at&quot;:&quot;16.03.2015 11:55:49&quot;,
 *               &quot;app_user&quot;:&quot;auto-create-on-init&quot;,
 *               &quot;module_name&quot;:&quot;layertreepanel&quot;,
 *               &quot;module_fullname&quot;:&quot;Standard Layer Tree&quot;,
 *               &quot;region&quot;:&quot;west&quot;,
 *               &quot;isDefault&quot;:true,
 *               &quot;type&quot;:&quot;internet&quot;
 *             },
 *             {
 *               &quot;id&quot;:3,
 *               &quot;created_at&quot;:&quot;16.03.2015 11:55:49&quot;,
 *               &quot;updated_at&quot;:&quot;16.03.2015 11:55:49&quot;,
 *               &quot;app_user&quot;:&quot;auto-create-on-init&quot;,
 *               &quot;module_name&quot;:&quot;overviewmappanel&quot;,
 *               &quot;module_fullname&quot;:&quot;Standard Overview Map&quot;,
 *               &quot;region&quot;:&quot;west&quot;,
 *               &quot;isDefault&quot;:true,
 *               &quot;type&quot;:&quot;internet&quot;
 *             },
 *             {
 *               &quot;id&quot;:2,
 *               &quot;created_at&quot;:&quot;16.03.2015 11:55:49&quot;,
 *               &quot;updated_at&quot;:&quot;16.03.2015 11:55:49&quot;,
 *               &quot;app_user&quot;:&quot;auto-create-on-init&quot;,
 *               &quot;module_name&quot;:&quot;layerlistpanel&quot;,
 *               &quot;module_fullname&quot;:&quot;Standard Layer List&quot;,
 *               &quot;region&quot;:&quot;west&quot;,
 *               &quot;isDefault&quot;:true,
 *               &quot;type&quot;:&quot;internet&quot;
 *             }
 *           ],
 *           &quot;grantedModules&quot;:null,
 *           &quot;groups&quot;:[],
 *           &quot;grantedGroups&quot;:null,
 *           &quot;orderedMapTools&quot;:[
 *             {
 *               &quot;id&quot;:3847,
 *               &quot;created_at&quot;:&quot;04.05.2015 12:05:29&quot;,
 *               &quot;updated_at&quot;:&quot;04.05.2015 12:05:29&quot;,
 *               &quot;app_user&quot;:&quot;default&quot;,
 *               &quot;module&quot;:{
 *                 &quot;id&quot;:4,
 *                 &quot;created_at&quot;:&quot;16.03.2015 11:55:49&quot;,
 *                 &quot;updated_at&quot;:&quot;16.03.2015 11:55:49&quot;,
 *                 &quot;app_user&quot;:&quot;auto-create-on-init&quot;,
 *                 &quot;module_name&quot;:&quot;navigation_select&quot;,
 *                 &quot;module_fullname&quot;:&quot;Werkzeuge zum Navigieren&quot;,
 *                 &quot;region&quot;:&quot;maptoolbar&quot;,
 *                 &quot;isDefault&quot;:false,
 *                 &quot;type&quot;:&quot;intranet&quot;
 *               },
 *               &quot;tbIndex&quot;:0
 *             },
 *             {
 *               &quot;id&quot;:3848,
 *               &quot;created_at&quot;:&quot;04.05.2015 12:05:29&quot;,
 *               &quot;updated_at&quot;:&quot;04.05.2015 12:05:29&quot;,
 *               &quot;app_user&quot;:&quot;default&quot;,
 *               &quot;module&quot;:{
 *                 &quot;id&quot;:5,
 *                 &quot;created_at&quot;:&quot;16.03.2015 11:55:50&quot;,
 *                 &quot;updated_at&quot;:&quot;16.03.2015 11:55:50&quot;,
 *                 &quot;app_user&quot;:&quot;auto-create-on-init&quot;,
 *                 &quot;module_name&quot;:&quot;query_evaluate&quot;,
 *                 &quot;module_fullname&quot;:&quot;Werkzeuge zum Abfragen&quot;,
 *                 &quot;region&quot;:&quot;maptoolbar&quot;,
 *                 &quot;isDefault&quot;:false,
 *                 &quot;type&quot;:&quot;intranet&quot;
 *               },
 *               &quot;tbIndex&quot;:1
 *             },
 *             {
 *               &quot;id&quot;:3849,
 *               &quot;created_at&quot;:&quot;04.05.2015 12:05:29&quot;,
 *               &quot;updated_at&quot;:&quot;04.05.2015 12:05:29&quot;,
 *               &quot;app_user&quot;:&quot;default&quot;,
 *               &quot;module&quot;:{
 *                 &quot;id&quot;:6,
 *                 &quot;created_at&quot;:&quot;16.03.2015 11:55:50&quot;,
 *                 &quot;updated_at&quot;:&quot;16.03.2015 11:55:50&quot;,
 *                 &quot;app_user&quot;:&quot;auto-create-on-init&quot;,
 *                 &quot;module_name&quot;:&quot;print_load_save&quot;,
 *                 &quot;module_fullname&quot;:&quot;Werkzeuge zum Drucken&quot;,
 *                 &quot;region&quot;:&quot;maptoolbar&quot;,
 *                 &quot;isDefault&quot;:false,
 *                 &quot;type&quot;:&quot;intranet&quot;
 *               },
 *               &quot;tbIndex&quot;:2
 *             },
 *             {
 *               &quot;id&quot;:3850,
 *               &quot;created_at&quot;:&quot;04.05.2015 12:05:29&quot;,
 *               &quot;updated_at&quot;:&quot;04.05.2015 12:05:29&quot;,
 *               &quot;app_user&quot;:&quot;default&quot;,
 *               &quot;module&quot;:{
 *                 &quot;id&quot;:7,
 *                 &quot;created_at&quot;:&quot;16.03.2015 11:55:50&quot;,
 *                 &quot;updated_at&quot;:&quot;16.03.2015 11:55:50&quot;,
 *                 &quot;app_user&quot;:&quot;auto-create-on-init&quot;,
 *                 &quot;module_name&quot;:&quot;annotate&quot;,
 *                 &quot;module_fullname&quot;:&quot;Werkzeuge zum Zeichnen&quot;,
 *                 &quot;region&quot;:&quot;maptoolbar&quot;,
 *                 &quot;isDefault&quot;:false,
 *                 &quot;type&quot;:&quot;intranet&quot;
 *               },
 *               &quot;tbIndex&quot;:3
 *             },
 *             {
 *               &quot;id&quot;:3851,
 *               &quot;created_at&quot;:&quot;04.05.2015 12:05:29&quot;,
 *               &quot;updated_at&quot;:&quot;04.05.2015 12:05:29&quot;,
 *               &quot;app_user&quot;:&quot;default&quot;,
 *               &quot;module&quot;:{
 *                 &quot;id&quot;:9,
 *                 &quot;created_at&quot;:&quot;16.03.2015 11:55:50&quot;,
 *                 &quot;updated_at&quot;:&quot;16.03.2015 11:55:50&quot;,
 *                 &quot;app_user&quot;:&quot;auto-create-on-init&quot;,
 *                 &quot;module_name&quot;:&quot;special_tools&quot;,
 *                 &quot;module_fullname&quot;:&quot;verschiedene Werkzeuge&quot;,
 *                 &quot;region&quot;:&quot;maptoolbar&quot;,
 *                 &quot;isDefault&quot;:false,
 *                 &quot;type&quot;:&quot;intranet&quot;
 *               },
 *               &quot;tbIndex&quot;:4
 *             }
 *           ],
 *           &quot;publicSearchLayer&quot;:null,
 *           &quot;publicResponsiveSearchLayer&quot;:3,
 *           &quot;layerTreeConfig&quot;:&quot;{\&quot;id\&quot;:2537,\&quot;name\&quot;:\&quot;Root\&quot;,\&quot;...&quot;,
 *           &quot;annotationGeometries&quot;:null,
 *           &quot;owner&quot;:1254,
 *           &quot;ownerName&quot;:&quot;Till Adams&quot;,
 *           &quot;additionalOwners&quot;:[],
 *           &quot;additionalOwnerIds&quot;:null,
 *           &quot;wpsActions&quot;:[],
 *           &quot;targetGroup&quot;:&quot;gisclient&quot;,
 *           &quot;maxResolution&quot;:560,
 *           &quot;minResolution&quot;:0.14
 *         },
 *         &quot;loggedInDspfUserId&quot;:&quot;6815&quot;,
 *         &quot;loggedInUser&quot;:&quot;Herr Till Adams&quot;,
 *         &quot;preferences&quot;:{}
 *       },
 *       &quot;total&quot;:1,
 *       &quot;success&quot;:true
 *     }
 */
/* Example of a simple broken down appcontext:
 *
 *     {
 *       &quot;data&quot;:{
 *         &quot;merge&quot;:{
 *           &quot;startCenter&quot;:[
 *             983487,
 *             6998170
 *           ],
 *           &quot;startZoom&quot;:13,
 *           &quot;mapLayers&quot;:[
 *             {
 *               &quot;name&quot;:&quot;Hintergrundkarten&quot;,
 *               &quot;type&quot;:&quot;Folder&quot;,
 *               &quot;layers&quot;:[
 *                 {
 *                   &quot;name&quot;:&quot;OSM WMS Grau&quot;,
 *                   &quot;type&quot;:&quot;TileWMS&quot;,
 *                   &quot;treeColor&quot;:&quot;rgba(41, 213, 4, 0.26)&quot;,
 *                   &quot;url&quot;:&quot;http://ows.terrestris.de/osm-gray/service?&quot;,
 *                   &quot;layers&quot;:&quot;OSM-WMS&quot;,
 *                   &quot;legendUrl&quot;:&quot;http://examples.com/legend.png&quot;,
 *                   &quot;topic&quot;:false
 *                 },
 *                 {
 *                   &quot;name&quot;:&quot;OSM WMS Farbig&quot;,
 *                   &quot;type&quot;:&quot;TileWMS&quot;,
 *                   &quot;treeColor&quot;:&quot;rgba(41, 213, 4, 0.26)&quot;,
 *                   &quot;url&quot;:&quot;http://ows.terrestris.de/osm/service?&quot;,
 *                   &quot;layers&quot;:&quot;OSM-WMS&quot;,
 *                   &quot;legendUrl&quot;:&quot;http://examples.com/legend.png&quot;,
 *                   &quot;topic&quot;:false,
 *                   &quot;visibility&quot;:false
 *                 },
 *                 {
 *                   &quot;name&quot;:&quot;Subfolder&quot;,
 *                   &quot;type&quot;:&quot;Folder&quot;,
 *                   &quot;layers&quot;:[
 *                     {
 *                       &quot;name&quot;:&quot;OSM WMS Farbig&quot;,
 *                       &quot;type&quot;:&quot;TileWMS&quot;,
 *                       &quot;treeColor&quot;:&quot;rgba(41, 213, 4, 0.26)&quot;,
 *                       &quot;url&quot;:&quot;http://ows.terrestris.de/osm/service?&quot;,
 *                       &quot;layers&quot;:&quot;OSM-WMS&quot;,
 *                       &quot;legendUrl&quot;:&quot;http://examples.com/legend.png&quot;,
 *                       &quot;topic&quot;:false,
 *                       &quot;visibility&quot;:false
 *                     }
 *                   ]
 *                 }
 *               ]
 *             },
 *             {
 *               &quot;name&quot;:&quot;OSM POIs&quot;,
 *               &quot;type&quot;:&quot;Folder&quot;,
 *               &quot;layers&quot;:[
 *                 {
 *                   &quot;name&quot;:&quot;Tankstellen&quot;,
 *                   &quot;type&quot;:&quot;WMS&quot;,
 *                   &quot;treeColor&quot;:&quot;rgba(161, 177, 228, 0.53)&quot;,
 *                   &quot;url&quot;:&quot;http://ows.terrestris.de/geoserver/osm/wms?&quot;,
 *                   &quot;legendHeight&quot;:40,
 *                   &quot;legendUrl&quot;:&quot;http://examples.com/legend.png&quot;,
 *                   &quot;layers&quot;:&quot;osm:osm-fuel&quot;,
 *                   &quot;topic&quot;:true,
 *                   &quot;transparent&quot;:true,
 *                   &quot;crossOrigin&quot;:&quot;Anonymous&quot;
 *                 },
 *                 {
 *                   &quot;name&quot;:&quot;Bushaltestellen&quot;,
 *                   &quot;type&quot;:&quot;WMS&quot;,
 *                   &quot;treeColor&quot;:&quot;rgba(161, 177, 228, 0.53)&quot;,
 *                   &quot;url&quot;:&quot;http://ows.terrestris.de/osm-haltestellen?&quot;,
 *                   &quot;legendHeight&quot;:30,
 *                   &quot;legendUrl&quot;:&quot;http://examples.com/legend.png&quot;,
 *                   &quot;layers&quot;:&quot;OSM-Bushaltestellen&quot;,
 *                   &quot;topic&quot;:true,
 *                   &quot;transparent&quot;:true,
 *                   &quot;crossOrigin&quot;:&quot;Anonymous&quot;
 *                 }
 *               ]
 *             }
 *           ],
 *           &quot;mapConfig&quot;:{
 *             &quot;projection&quot;:&quot;EPSG:3857&quot;,
 *             &quot;resolutions&quot;:[
 *               156543.03390625,
 *               78271.516953125,
 *               39135.7584765625,
 *               19567.87923828125,
 *               9783.939619140625,
 *               4891.9698095703125,
 *               2445.9849047851562,
 *               1222.9924523925781,
 *               611.4962261962891,
 *               305.74811309814453,
 *               152.87405654907226,
 *               76.43702827453613,
 *               38.218514137268066,
 *               19.109257068634033,
 *               9.554628534317017,
 *               4.777314267158508,
 *               2.388657133579254,
 *               1.194328566789627,
 *               0.5971642833948135
 *             ],
 *             &quot;zoom&quot;:0
 *           }
 *         }
 *       }
 *     }
 */
Ext.define(&#39;BasiGX.util.ConfigParser&#39;, {

    autocreateLegends: false,

    activeRouting: false,

    appContext: null,

    statics: {

<span id='BasiGX-util-ConfigParser-property-layerArray'>        /**
</span>         * The layer array which will hold the the maps layers and grouplayers.
         */
        layerArray: [],

<span id='BasiGX-util-ConfigParser-method-setupMap'>        /**
</span>         * Method creates an ol map and its layers based on the given context
         *
         * @param {Object} context The context object
         * @return {ol.Map} An ol-map or null if an invalid context was given.
         */
        setupMap: function(context) {
            var me = this;
            var config;

            if (!context || !context.data || !context.data.merge ||
                !context.data.merge.mapConfig) {
                Ext.log.warn(&#39;Invalid context given to configParser!&#39;);
                return null;
            }

            config = context.data.merge;
            me.appContext = config;

            // TODO Refactor
            if (window.location.hash.indexOf(&#39;center&#39;) &gt; 0) {
                var centerString = window.location.hash.split(&#39;center/&#39;)[1].
                    split(&#39;|&#39;)[0];
                config.startCenter = centerString;
            }

            me.map = new ol.Map({
                controls: [new ol.control.ScaleLine()], // TODO add attribution
                view: new ol.View({
                    center: this.convertStringToNumericArray(
                        &#39;int&#39;, config.startCenter),
                    zoom: config.startZoom || 2,
                    maxResolution: config.maxResolution,
                    minResolution: config.minResolution,
                    projection: config.mapConfig.projection || &#39;EPSG:3857&#39;,
                    units: &#39;m&#39;,
                    resolutions: me.convertStringToNumericArray(
                        &#39;float&#39;, config.mapConfig.resolutions)
                }),
                logo: false
            });
            // create the layers
            me.getLayersArray(context);
            // add the layers
            var layerGroup = new ol.layer.Group({
                layers: me.layerArray.reverse()
            });
            me.map.setLayerGroup(layerGroup);

            return me.map;
        },

<span id='BasiGX-util-ConfigParser-method-createLayer'>        /**
</span>         * Creates an ol layer based on a config object
         *
         * @param {Object} layer - the layer object
         * @return {ol.Layer} - An ol layer object
         */
        createLayer: function(layer) {
            var me = this;
            var layerType = &#39;Image&#39;;
            var sourceType = &#39;ImageWMS&#39;;

            if (layer.type === &#39;TileWMS&#39; || layer.type === &#39;WMS&#39;) {
                layerType = &#39;Tile&#39;;
                sourceType = &#39;TileWMS&#39;;
            } else if (layer.type === &#39;XYZ&#39;) {
                layerType = &#39;Tile&#39;;
                sourceType = &#39;XYZ&#39;;
            } else if (layer.type === &#39;WFSCluster&#39; || layer.type === &#39;WFS&#39;) {
                layerType = &#39;Vector&#39;;
                sourceType = &#39;Vector&#39;;
            } else if (layer.type === &#39;WMTS&#39;) {
                layerType = &#39;WMTS&#39;;
                sourceType = &#39;WMTS&#39;;
            }

            var source = me.getSourceForType(layer, sourceType);
            return me.getLayerForType(layer, layerType, source);
        },

<span id='BasiGX-util-ConfigParser-method-getSourceForType'>        /**
</span>         * Returns an OpenLayers source for the passed config and given type.
         *
         * @param {Object} config The layer configuration.
         * @param {String} sourceType The type of the source to create.
         * @return {ol.source.Source} An OpenLayers source.
         */
        getSourceForType: function(config, sourceType) {

            var me = this;
            var map = me.map;
            var projection = map.getView().getProjection();
            var projCode = map.getView().getProjection().getCode();
            var cfg;

            var attributions = config.attribution ?
                [new ol.Attribution({html: config.attribution})] : undefined;

            if (sourceType === &#39;Vector&#39;) {

                // The wfscluster type expects a geoserver view similar
                // as described on https://wiki.intranet.terrestris.de/doku.php
                // ?id=clustering
                //
                // There is currently no way in ol to request features on
                // every extent change, so we need to handle it ourselves with
                // map listeners, which happens in the cluster plugin
                if (config.type === &#39;WFSCluster&#39;) {
                    cfg = {
                        attributions: attributions
                    };
                } else {
                    cfg = {
                        attributions: attributions,
                        loader: function(extent/*, resolution, projection */) {
                            // eslint-disable-next-line consistent-this
                            var vectorSource = this;
                            var extraParams = {};

                            var finalParams = Ext.apply({
                                service: &#39;WFS&#39;,
                                version: &#39;1.1.0&#39;,
                                request: &#39;GetFeature&#39;,
                                outputFormat: &#39;application/json&#39;,
                                typeName: config.layers,
                                srsname: projCode,
                                bbox: extent.join(&#39;,&#39;) + &#39;,&#39; + projCode
                            }, extraParams || {});

                            Ext.Ajax.request({
                                url: config.url,
                                method: &#39;GET&#39;,
                                params: finalParams,
                                success: function(response) {
                                    var format = new ol.format.GeoJSON();
                                    var features = format.readFeatures(
                                        response.responseText
                                    );
                                    vectorSource.addFeatures(features);
                                },
                                failure: function(response) {
                                    var msg = &#39;server-side failure with &#39; +
                                        &#39;status code &#39; + response.status;
                                    Ext.log.info(msg);
                                }
                            });

                        },
                        strategy: ol.loadingstrategy.tile(
                            ol.tilegrid.createXYZ({
                                maxZoom: 28
                            })
                        )
                    };
                }
            } else if (sourceType === &#39;TileWMS&#39; ||
                       sourceType === &#39;WMS&#39; ||
                       sourceType === &#39;ImageWMS&#39; ||
                       sourceType === &#39;XYZ&#39;) {

                cfg = {
                    url: config.url,
                    crossOrigin: config.crossOrigin,
                    attributions: attributions,
                    params: {
                        LAYERS: config.layers,
                        TRANSPARENT: config.transparent || true,
                        VERSION: config.version || &#39;1.1.1&#39;
                    }
                };

                // set a tilegrid if needed
                if (me.appContext &amp;&amp;
                    me.appContext.mapConfig &amp;&amp;
                    me.appContext.mapConfig.resolutions &amp;&amp;
                    (config.type === &#39;TileWMS&#39; || config.type === &#39;XYZ&#39;) &amp;&amp;
                    config.tileGrid === undefined) {
                    cfg.tileGrid = new ol.tilegrid.TileGrid({
                        extent: map.getView().getProjection().getExtent(),
                        resolutions: me.convertStringToNumericArray(
                            &#39;float&#39;, me.appContext.mapConfig.resolutions)
                    });
                }

                if ((config.type === &#39;TileWMS&#39; ||
                     config.type === &#39;WMS&#39; ||
                     config.type === &#39;XYZ&#39;) &amp;&amp; config.tiled) {
                    cfg.params.TILED = true;
                }

            } else if (sourceType === &#39;WMTS&#39;) {
                var tileGrid;
                // we simply assume it is a worldwide layer
                var origin = ol.extent.getTopLeft(projection.getExtent());
                var projectionExtent = projection.getExtent();
                var size = ol.extent.getWidth(projectionExtent) / 256;
                var resolutions = new Array(14);
                var matrixIds = new Array(14);
                for (var z = 0; z &lt; 14; ++z) {
                    // generate resolutions and matrixIds arrays for this
                    // WMTS
                    resolutions[z] = size / Math.pow(2, z);
                    matrixIds[z] = z;
                }
                tileGrid = new ol.tilegrid.WMTS({
                    origin: origin,
                    resolutions: resolutions,
                    matrixIds: matrixIds
                });

                cfg = {
                    url: config.url,
                    layer: config.layers,
                    attributions: attributions,
                    matrixSet: config.tilematrixset,
                    format: config.format,
                    projection: projection,
                    tileGrid: tileGrid,
                    style: config.style
                };
            }

            return new ol.source[sourceType](cfg);

        },

<span id='BasiGX-util-ConfigParser-method-getLayerForType'>        /**
</span>         * Returns an OpenLayers layer for the passed configuration, type and
         * source.
         *
         * @param {Object} layer The layer configuration.
         * @param {String} layerType The layertype.
         * @param {ol.source.Source} source The layer source.
         * @return {ol.layer.Base} The created layer.
         */
        getLayerForType: function(layer, layerType, source) {

            var olLayerConfig = {
                name: layer.name || &#39;No Name given&#39;,
                legendUrl: layer.legendUrl || (this.autocreateLegends ?
                    this.generateLegendUrl(layer) : null),
                legendHeight: layer.legendHeight || null,
                minResolution: layer.minResolution || undefined,
                maxResolution: layer.maxResolution || undefined,
                opacity: layer.opacity || 1,
                visible: (layer.visibility === false) ? false : true,
                treeColor: layer.treeColor,
                routingId: layer.id || null,
                olStyle: layer.olStyle || null,
                // TODO we should get rid of `topic`
                topic: layer.topic || layer.hoverField || null,
                source: source,
                type: layer.type,
                featureType: layer.layers
            };

            // We don&#39;t require the hover plugin class to allow for smaller
            // builds
            if (&#39;plugin&#39; in BasiGX &amp;&amp; &#39;Hover&#39; in BasiGX.plugin) {
                var hoverCls = BasiGX.plugin.Hover;
                var hoverableProp = hoverCls.LAYER_HOVERABLE_PROPERTY_NAME;
                var hoverfieldProp = hoverCls.LAYER_HOVERFIELD_PROPERTY_NAME;
                var shallHover = false;
                if (hoverableProp in layer) {
                    shallHover = layer[hoverableProp];
                } else {
                    shallHover = !!layer[hoverfieldProp];
                }
                olLayerConfig[hoverableProp] = shallHover;
                olLayerConfig[hoverfieldProp] = layer[hoverfieldProp];
            }

            // TODO Refactor ... Do we need an icon or a color...
            if (layer.type === &#39;WFSCluster&#39;) {
                if (!layer.clusterColorString) {
                    var r = Math.round(Math.random() * 255, 10).toString();
                    var g = Math.round(Math.random() * 255, 10).toString();
                    var b = Math.round(Math.random() * 255, 10).toString();
                    olLayerConfig.clusterColorString =
                        &#39;rgba(&#39; + r + &#39;,&#39; + g + &#39;,&#39; + b + &#39;,0.5)&#39;;
                } else {
                    olLayerConfig.clusterColorString = layer.clusterColorString;
                }
                olLayerConfig.icon = layer.icon;
            }

            // apply custom params of layer from appContext
            if (layer.customParams) {
                Ext.applyIf(olLayerConfig, layer.customParams);
            }

            return new ol.layer[layerType](olLayerConfig);
        },

<span id='BasiGX-util-ConfigParser-method-createFolder'>        /**
</span>         * Creates an ol layer group.
         *
         * @param {Object} node The node which has been identified as group
         * @return {ol.layer.Group} An ol-layer group
         */
        createFolder: function(node) {
            return new ol.layer.Group({
                name: node.name,
                visible: node.checked ? node.checked : false
            });
        },

<span id='BasiGX-util-ConfigParser-method-getLayersArray'>        /**
</span>         * This method gets called internally by the setupMap method, so there
         * should be no need to call this directly
         *
         * @param {Object} context The context holding the layers config
         */
        getLayersArray: function(context) {
            var me = this;
            var layerConfig;
            var layerTreeConfig;

            if (!context || !context.data || !context.data.merge ||
                !context.data.merge.mapLayers) {
                Ext.log.warn(&#39;Invalid context given to configParser!&#39;);
                return;
            }

            layerConfig = context.data.merge.mapLayers;
            layerTreeConfig = Ext.decode(context.data.merge.layerTreeConfig);

            if (!Ext.isEmpty(layerTreeConfig)) {
                // we have a SHOGun context and need to iterate through
                // the treeconfig to get access to folders and special
                // layer information
                me.createLayersArrayFromShogunContext(
                    layerTreeConfig, layerConfig
                );
            } else {
                me.createLayersArray(layerConfig);
            }
        },

<span id='BasiGX-util-ConfigParser-method-createLayersArray'>        /**
</span>         * Method sets up an layer and grouplayer collection for an ol map
         *
         * @param {Object} layerConfig The layerconfig object
         * @param {ol.layer.Group} parent The parent to which we may append
         */
        createLayersArray: function(layerConfig, parent) {
            var me = this;

            Ext.each(layerConfig, function(node) {

                if (node.type === &#39;Folder&#39;) {
                    var folder = me.createFolder(node);

                    if (parent) {
                        parent.getLayers().push(folder);
                    } else {
                        me.layerArray.push(folder);
                    }

                    // create child nodes if necessary
                    if (node.layers &amp;&amp; node.layers.length &gt; 0) {
                        me.createLayersArray(node.layers, folder);
                    }

                } else {
                    if (parent) {
                        parent.getLayers().push(me.createLayer(node));
                    } else {
                        me.layerArray.push(me.createLayer(node));
                    }
                }
            }, me);
        },

<span id='BasiGX-util-ConfigParser-method-createLayersArrayFromShogunContext'>        /**
</span>         * Method sets up an layer and grouplayer collection for an ol map
         * based on an SHOGun application Context
         *
         * @param {Object} treeCfg The layerTreeConfig object
         * @param {Object} layerCfg The layerconfig object
         * @param {ol.layer.Group} group The parent to which we may append
         */
        createLayersArrayFromShogunContext: function(treeCfg, layerCfg, group) {
            var me = this;

            Ext.each(treeCfg, function(node) {

                //handling the rootnode first
                if (node.parentId === null &amp;&amp; node.children) {
                    me.createLayersArrayFromShogunContext(
                        node.children, layerCfg
                    );
                } else if (node.leaf === false) {
                    // handling folders
                    var folder = me.createFolder(node);
                    folder.set(&#39;expanded&#39;, node.expanded);

                    if (group) {
                        group.getLayers().push(folder);
                        folder.set(&#39;parentFolder&#39;, group);
                    } else {
                        me.layerArray.push(folder);
                    }

                    // create child nodes if necessary
                    if (node.children &amp;&amp; node.children.length &gt; 0) {
                        me.createLayersArrayFromShogunContext(
                            node.children.reverse(), layerCfg, folder);
                    }

                } else {

                    // handling layers
                    // get node from config by its id
                    var mergedNode = me.getNodeFromConfigById(
                        node.mapLayerId, layerCfg
                    );
                    // adding properties from treeConfig to node from
                    // layerconfig
                    mergedNode.visibility = node.checked;
                    mergedNode.expanded = node.expanded;

                    if (group) {
                        group.getLayers().getArray().push(
                            me.createLayer(mergedNode)
                        );
                        if (node.checked) {
                            group.set(&#39;visible&#39;, true);
                            var nextParent = group.get(&#39;parentFolder&#39;);
                            while (nextParent) {
                                nextParent.set(&#39;visible&#39;, true);
                                nextParent = nextParent.get(&#39;parentFolder&#39;);
                            }
                        }
                    } else {
                        me.layerArray.push(me.createLayer(mergedNode));
                    }
                }
            }, me);
        },

<span id='BasiGX-util-ConfigParser-method-getNodeFromConfigById'>        /**
</span>         * Method retrieves a layerconfig object by the given id.
         *
         * @param {Number} mapLayerId The mapLayerId.
         * @param {Array} layerConfig a list of layer confgs to search in.
         * @return {Object} The layer object that has been found.
         */
        getNodeFromConfigById: function(mapLayerId, layerConfig) {
            var match;
            Ext.each(layerConfig, function(layer) {
                if (layer.id === mapLayerId) {
                    match = layer;
                    return false;
                }
            });
            return match;
        },

<span id='BasiGX-util-ConfigParser-method-convertStringToNumericArray'>        /**
</span>         * Method turns a comma separated string into an array containing
         * integers or floats. If passed an array, parse{Int,Float} will be
         * called on each item.
         *
         * @param {String} type The type to convert to.
         * @param {String | Array} string The string to convert.
         * @return {Array} The parsed array.
         */
        convertStringToNumericArray: function(type, string) {
            if (Ext.isEmpty(string) || Ext.isEmpty(type)) {
                Ext.log.warn(&#39;Cannot convert string to numeric array. Passed &#39; +
                    &#39;type was: &#39; + type + &#39;; Passed string was: &#39; + string);
                return string;
            }
            if (Ext.isArray(string)) {
                var result = [];
                Ext.each(string, function(item) {
                    if (type === &#39;int&#39;) {
                        result.push(parseInt(item, 10));
                    } else if (type === &#39;float&#39;) {
                        result.push(parseFloat(item, 10));
                    }
                });
                return result;
            }
            var arr = [];
            Ext.each(string.split(&#39;,&#39;), function(part) {
                if (type === &#39;int&#39;) {
                    arr.push(parseInt(part, 10));
                } else if (type === &#39;float&#39;) {
                    arr.push(parseFloat(part, 10));
                }
            });
            return arr;
        },

<span id='BasiGX-util-ConfigParser-method-generateLegendUrl'>        /**
</span>         * Method creates a hopefully valid getlegendgraphic request for the
         * given layer.
         *
         * @param {Object} layer A layer configuration.
         * @return {String} The generated legend URL.
         */
        generateLegendUrl: function(layer) {
            var url = layer.url;
            url += &#39;?SERVICE=WMS&amp;VERSION=1.3.0&amp;REQUEST=GetLegendGraphic&amp;&#39;;
            url += &#39;FORMAT=image%2Fpng&amp;TRANSPARENT=TRUE&amp;&#39;;
            url += &#39;LAYER=&#39; + layer.layers;
            // HEIGHT=128&amp;WIDTH=40&amp; could be added.
            return url;
        }
    }
});
</pre>
</body>
</html>
